---
title: "M1.3 게임 필 - 화면/나무 흔들림"
type: feat
date: 2026-01-26
milestone: M1
task_id: M1.3
depends_on: [M1.2]
scripts: 2
---

# M1.3: 게임 필 - 화면/나무 흔들림

## 목표

클릭 시 화면 흔들림과 나무 흔들림 피드백을 구현합니다.

## 의존성

- **M1.2**: TreeController에서 treeShake 호출

## 작업 내용

### 1. ScreenShake.cs

**파일:** `Assets/02.Scripts/Effects/ScreenShake.cs`

```csharp
using System.Collections;
using UnityEngine;

/// <summary>
/// 카메라 화면 흔들림 효과
/// </summary>
public class ScreenShake : MonoBehaviour
{
    [SerializeField] private float shakeDuration = 0.05f;
    [SerializeField] private float shakeMagnitude = 0.1f;

    private Vector3 originalPosition;
    private Coroutine shakeCoroutine;

    private void Start()
    {
        originalPosition = transform.localPosition;

        // GameEvents 구독
        if (GameEvents.Instance != null)
        {
            GameEvents.Instance.OnTreeHit += Shake;
        }
    }

    private void OnDestroy()
    {
        if (GameEvents.Instance != null)
        {
            GameEvents.Instance.OnTreeHit -= Shake;
        }
    }

    public void Shake()
    {
        if (shakeCoroutine != null)
        {
            StopCoroutine(shakeCoroutine);
            transform.localPosition = originalPosition;
        }
        shakeCoroutine = StartCoroutine(ShakeCoroutine());
    }

    private IEnumerator ShakeCoroutine()
    {
        float elapsed = 0f;

        while (elapsed < shakeDuration)
        {
            float x = Random.Range(-1f, 1f) * shakeMagnitude;
            float y = Random.Range(-1f, 1f) * shakeMagnitude;
            transform.localPosition = originalPosition + new Vector3(x, y, 0);
            elapsed += Time.deltaTime;
            yield return null;
        }

        transform.localPosition = originalPosition;
        shakeCoroutine = null;
    }
}
```

### 2. TreeShake.cs

**파일:** `Assets/02.Scripts/Effects/TreeShake.cs`

```csharp
using System.Collections;
using UnityEngine;

/// <summary>
/// 나무 흔들림 효과
/// 타격 방향 반대로 기울였다가 복귀
/// </summary>
public class TreeShake : MonoBehaviour
{
    [SerializeField] private float shakeAngle = 15f;
    [SerializeField] private float shakeDuration = 0.2f;

    private Quaternion originalRotation;
    private Coroutine shakeCoroutine;

    private void Awake()
    {
        originalRotation = transform.rotation;
    }

    public void Shake(Vector3 hitDirection)
    {
        if (shakeCoroutine != null)
        {
            StopCoroutine(shakeCoroutine);
            transform.rotation = originalRotation;
        }
        shakeCoroutine = StartCoroutine(ShakeCoroutine(hitDirection));
    }

    private IEnumerator ShakeCoroutine(Vector3 direction)
    {
        // 타격 반대 방향으로 기울임
        float tiltDirection = -Mathf.Sign(direction.x);
        if (Mathf.Abs(direction.x) < 0.1f)
        {
            tiltDirection = Random.value > 0.5f ? 1f : -1f;
        }

        Quaternion targetRotation = Quaternion.Euler(
            originalRotation.eulerAngles.x,
            originalRotation.eulerAngles.y,
            originalRotation.eulerAngles.z + shakeAngle * tiltDirection
        );

        // Phase 1: 빠르게 기울임 (30%)
        float elapsed = 0f;
        float tiltDuration = shakeDuration * 0.3f;
        while (elapsed < tiltDuration)
        {
            float t = elapsed / tiltDuration;
            // EaseOut 커브
            t = 1 - (1 - t) * (1 - t);
            transform.rotation = Quaternion.Lerp(originalRotation, targetRotation, t);
            elapsed += Time.deltaTime;
            yield return null;
        }

        // Phase 2: 천천히 복귀 (70%)
        elapsed = 0f;
        float returnDuration = shakeDuration * 0.7f;
        while (elapsed < returnDuration)
        {
            float t = elapsed / returnDuration;
            // EaseInOut 커브
            t = t < 0.5f ? 2 * t * t : 1 - Mathf.Pow(-2 * t + 2, 2) / 2;
            transform.rotation = Quaternion.Lerp(targetRotation, originalRotation, t);
            elapsed += Time.deltaTime;
            yield return null;
        }

        transform.rotation = originalRotation;
        shakeCoroutine = null;
    }
}
```

## 씬 설정

### ScreenShake 설정

1. **Main Camera에 ScreenShake 추가:**
   - Main Camera 선택
   - ScreenShake.cs 컴포넌트 추가
   - shakeDuration: 0.05
   - shakeMagnitude: 0.1

### TreeShake 설정

1. **나무 오브젝트에 TreeShake 추가:**
   - 나무 오브젝트 선택
   - TreeShake.cs 컴포넌트 추가
   - shakeAngle: 15
   - shakeDuration: 0.2

2. **TreeController 연결:**
   - TreeController의 treeShake 필드에 TreeShake 연결
   - 또는 GetComponent로 자동 탐색 (기본 동작)

## 파라미터 가이드

| 파라미터 | 권장값 | 설명 |
|----------|--------|------|
| ScreenShake.shakeDuration | 0.03~0.08 | 너무 길면 어지러움 |
| ScreenShake.shakeMagnitude | 0.05~0.15 | 화면 크기 대비 이동량 |
| TreeShake.shakeAngle | 10~20 | 기울기 각도 |
| TreeShake.shakeDuration | 0.15~0.3 | 복귀까지 총 시간 |

## Acceptance Criteria

- [ ] ScreenShake.cs 컴파일 성공
- [ ] TreeShake.cs 컴파일 성공
- [ ] 나무 클릭 시 화면 흔들림 발생
- [ ] 나무 클릭 시 나무 기울임 → 복귀 동작
- [ ] 연속 클릭 시 이전 흔들림 취소 후 새로 시작

## 테스트 방법

1. Play 모드 시작
2. 나무 클릭
3. 카메라가 잠깐 흔들리는지 확인
4. 나무가 타격 반대 방향으로 기울였다가 복귀하는지 확인
5. 빠르게 연속 클릭해도 부드럽게 동작하는지 확인

## 다음 태스크

→ M1.7 통합 테스트 (M1.4, M1.5, M1.6 완료 후)
