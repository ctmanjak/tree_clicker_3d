---
title: "M1.2 나무 및 기본 UI"
type: feat
date: 2026-01-26
milestone: M1
task_id: M1.2
depends_on: [M1.1]
scripts: 2
---

# M1.2: 나무 및 기본 UI

## 목표

클릭 가능한 나무 오브젝트와 목재 카운터 UI를 구현합니다.

## 의존성

- **M1.0**: IClickable 인터페이스
- **M1.1**: GameManager, InputHandler

## 작업 내용

### 1. TreeController.cs

**파일:** `Assets/02.Scripts/Tree/TreeController.cs`

```csharp
using UnityEngine;

/// <summary>
/// 나무 오브젝트 컨트롤러
/// IClickable 인터페이스로 클릭 처리
/// </summary>
public class TreeController : MonoBehaviour, IClickable
{
    [SerializeField] private TreeShake treeShake;
    [SerializeField] private HitParticleSpawner particleSpawner;

    private GameManager gameManager;
    private GameEvents gameEvents;

    private void Start()
    {
        gameManager = GameManager.Instance;
        gameEvents = GameEvents.Instance;

        // 컴포넌트 자동 탐색 (Inspector 설정 안된 경우)
        if (treeShake == null) treeShake = GetComponent<TreeShake>();
        if (particleSpawner == null) particleSpawner = GetComponent<HitParticleSpawner>();
    }

    /// <summary>
    /// IClickable 구현 - InputHandler에서 직접 호출
    /// </summary>
    public void OnClick(Vector3 hitPoint)
    {
        // 목재 획득
        gameManager.AddWood(gameManager.WoodPerClick);

        // 이벤트 발행 (UI, 이펙트 등에서 구독)
        gameEvents.RaiseTreeHit();

        // 나무 흔들림 (선택적 - M1.3에서 구현)
        Vector3 hitDirection = (hitPoint - transform.position).normalized;
        treeShake?.Shake(hitDirection);
    }
}
```

### 2. WoodCounterUI.cs

**파일:** `Assets/02.Scripts/UI/WoodCounterUI.cs`

```csharp
using UnityEngine;
using TMPro;

/// <summary>
/// 목재 카운터 UI
/// GameEvents 구독하여 실시간 업데이트
/// </summary>
public class WoodCounterUI : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI woodText;

    private GameEvents gameEvents;

    private void Start()
    {
        gameEvents = GameEvents.Instance;
        // 초기값 표시
        UpdateDisplay(GameManager.Instance.CurrentWood);
    }

    private void OnEnable()
    {
        // Start 전에 호출될 수 있으므로 null 체크
        if (GameEvents.Instance != null)
        {
            GameEvents.Instance.OnWoodChanged += UpdateDisplay;
        }
    }

    private void OnDisable()
    {
        if (GameEvents.Instance != null)
        {
            GameEvents.Instance.OnWoodChanged -= UpdateDisplay;
        }
    }

    private void UpdateDisplay(long amount)
    {
        woodText.text = FormatNumber(amount);
    }

    private string FormatNumber(long num)
    {
        if (num >= 1_000_000_000) return $"{num / 1_000_000_000f:F1}B";
        if (num >= 1_000_000) return $"{num / 1_000_000f:F1}M";
        if (num >= 1_000) return $"{num / 1_000f:F1}K";
        return num.ToString();
    }
}
```

## 씬 설정

### 나무 오브젝트 설정

1. **나무 모델 배치:**
   - LowpolyNatureBundle 또는 Supercyan에서 나무 모델 선택
   - 씬 중앙에 배치 (Position: 0, 0, 0)

2. **컴포넌트 추가:**
   - TreeController.cs 추가
   - Collider 추가 (Box 또는 Capsule)
   - Tag: "Tree" 설정
   - Layer: "Clickable" 설정

3. **태그 생성:**
   - Edit > Project Settings > Tags and Layers
   - Tag 0: "Tree" 추가

### UI Canvas 설정

1. **Canvas 생성:**
   - UI > Canvas
   - Render Mode: Screen Space - Overlay
   - UI Scale Mode: Scale With Screen Size
   - Reference Resolution: 1920 x 1080

2. **목재 카운터 UI:**
   ```
   Canvas
   └── WoodCounter (Empty)
       ├── Icon (Image) - 나무 아이콘
       └── WoodText (TextMeshPro)
   ```

3. **WoodCounter 설정:**
   - Anchor: Top Left
   - Position: (100, -50, 0)
   - WoodCounterUI.cs 컴포넌트 추가
   - woodText 필드에 WoodText 연결

4. **WoodText 설정:**
   - Font Size: 48
   - Alignment: Left
   - Color: White
   - Text: "0"

## Acceptance Criteria

- [ ] TreeController.cs 컴파일 성공
- [ ] WoodCounterUI.cs 컴파일 성공
- [ ] 나무 클릭 시 GameManager.CurrentWood 증가
- [ ] WoodCounterUI에 현재 목재량 표시
- [ ] 1000 이상 → "1.0K" 포맷 표시
- [ ] 1000000 이상 → "1.0M" 포맷 표시

## 테스트 방법

1. Play 모드 시작
2. 나무 클릭 → WoodCounterUI "1" 표시
3. 10번 클릭 → "10" 표시
4. Inspector에서 GameManager.currentWood = 1500 설정 → "1.5K" 표시

## 다음 태스크

→ M1.3 게임 필 - 화면/나무 흔들림 (병렬 가능)
→ M1.4 게임 필 - 플로팅 텍스트/파티클 (병렬 가능)
